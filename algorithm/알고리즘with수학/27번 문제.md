N개의 공이 있고, 각각의 공에는 1부터 N까지의 정수가 적혀있습니다. 정수 N이 주어질 때, $k=1,2,3\dots , N$에 대해서 다음과 같은 질문에 답하는 프로그램을 작성해 주세요.
- N개의 공에서 1개 이상의 공을 선택하는 방법은 $2^N-1$가지 존재합니다. 이 중에서 다음과 같은 조건을 만족하는 선택 방법이 몇 가지 있는지를 1000000007로 나눈 나머지를 구해 주세요.
- 조건 : 어떤 2개의 공을 선택해도 적혀있는 정수의 차가 $k$ 이상이어야 합니다.

$1\leq N\leq 100000$을 만족하는 입력에서 2초 이내에 답을 구하게 구성해 주세요(출전 : 競プロ典型 90 問015 - Don't be too close).

제약<br>
- $1\leq N\leq 10^5$<br>
- N은 정수입니다.

실행 시간 제한
- 2초

입력
- N

출력
- N줄 출력합니다. i($1\leq i\leq N$)번째 줄에는 $k=i$일 때의 답을 $10^9+7$로 나눈 나머지를 출력해 주세요.

입력 예1
```
1
```
출력 예1
```
1
```
입력 예2
```
2
```
출력 예2
```
3
2
```
입력 예3
```
20
```
출력 예3
```
1048575
17710
2744
906
430
250
167
118
90
75
65
56
48
41
35
30
26
23
21
20
```

# 해답
i번째 줄에 각 수가 i만큼 차이가 나야 한다면, 전체 집합으로 풀지 않고, i개의 집합들의 조합으로 풀면 될 것입니다.

20개에서 1개를 뽑을 확률 $20C1$의 답인 20부터, $20C2+20C3+\dots+20C20$까지의 답을 구했음

20+190+1140+4845+15504+38760+77520+125970+167960+184756+167960+125970+77520+38760+15504+4845+1140+190+20+1의 결과값이 입력값이 20일때의 첫째 줄 츨력값과 동일함을 알 수 있었음

## 수학적 요소
### 조합(combination)
$nCm=\frac{n!}{m!\cdot(n-m!)}$ 가 성립합니다.

## 코드
```cpp
#include <iostream>
using namespace std;

const int MOD = 1000000007;

long long power(long long x, long long y) 
{
    long long result = 1;
    while (y > 0) 
    {
        if (y % 2 == 1)
            result = (result * x) % MOD;
        x = (x * x) % MOD;
        y /= 2;
    }
    return result;
}

long long combination(int N, int K) {
    long long result = 1;
    for (int i = 0; i < K; ++i) {
        result = (result * (N - i)) % MOD;
        result = (result * power(i + 1, MOD - 2)) % MOD;
    }
    return result;
}

int main() {
    int N;
    cin >> N;

    for (int k = 1; k <= N; ++k) {
        long long result = 0;

        for (int m = 1; m <= N; ++m) 
        {
            int M = N - (m - 1) * (k - 1);
            if (M<= 0)
                break;
            long long ways = combination(M, m);
            result = (result + ways) % MOD;
        }

        cout << result << endl;
    }

    return 0;
}

```

### long long power(long long x, long long y) 
나눗셈 모듈러 연산을 위해 역원을 찾기위해 사용하였습니다.

### long long combination(int N, int K) 
조합을 수행하기 위해 만들었습니다.

## 외부 반복문
1번째 줄부터 N번째 줄까지 반복하여 출력해야 함으로 1~N까지 반복하는 for문으로 만들어 졌습니다.

## 내부 반복문
### int M = N - (m - 1) * (k - 1);
우선 (m-1) * (k-1) 부분의 경우 공들의 최소 간격을 나타냅니다.

m은 선택할 공의 갯수, k는 선택한 공의 차이를 나타냅니다.

N이 10이고, k와 m이 3이라고 가정했을 때,

$(1,2,3) (4,5,6) (7,8,9) 10$

다음과 같이 나타낼 수 있습니다.

()는 k를 보기 좋게 형상화 항 것입니다. k만큼 차이가 나야 하기에 괄호 안의 것끼리는 동시에 고를 수 없습니다. 그러기에 각 그룹내의 원소간의 거리는 (k - 1)

m은 선택할 그룹의 갯수입니다. 각 그룹간의 거리는 (m - 1)

그러기에 이 둘을 곱하고, 전체 공의 갯수인 N에 해당 값을 빼줌으로써 남아있는 공의 양을 찾을 수 있습니다.

### if (M<= 0) break;
위의 값이 음수일 경우 동작하면 안됨으로 해당 조건을 달았습니다.
음수일시, 남아있는 공은 존재하지 않으므로 동작하면 안됩니다.