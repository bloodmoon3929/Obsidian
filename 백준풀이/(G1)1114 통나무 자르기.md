---
completed: 
note:
  - "[[정렬]]"
---
## 문제

벌목꾼 백은진은 나무를 종이 공장에 옮겨야 한다. 하지만, 통나무의 길이가 너무 길어서 트럭에 들어가지 않으므로, 여러개의 조각으로 나누려고 한다.

통나무의 길이는 L이고, K개의 위치에서만 자를 수 있다. 통나무를 자를 수 있는 위치가 주어진다. 이 위치는 통나무의 가장 왼쪽에서부터 떨어진 거리이다. 통나무를 자를 수 있는 횟수는 최대 C번이다.

통나무의 가장 긴 조각을 작게 만들고, 그 길이를 구해보자.

## 입력

첫째 줄에 세 정수 L, K, C가 주어진다. 둘째 줄에는 통나무를 자를 수 있는 위치가 주어진다.

## 해답
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> arr;
long long L, C, K;

bool possible(int mid) 
{
    int cut = 0, sum = 0;
    
    for (int i = 1; i < arr.size(); ++i) 
    {
        if (arr[i] - arr[i - 1] > mid)
            return false;
        if (sum + arr[i] - arr[i - 1] > mid) 
        {
            cut++;
            sum = arr[i] - arr[i - 1];
        } 
        else 
            sum += arr[i] - arr[i - 1];
    }
    return cut <= C;
}

long long binarySearch() 
{
    long long low = 0, high = L;
    while (low + 1 < high) 
    {
        long long mid = (low + high) / 2;
        if (possible(mid))
            high = mid;
        else
            low = mid;
    }
    return high;
}


int main() 
{
    cin >> L >> K >> C;
    arr.resize(K + 1);
    for (int i = 1; i <= K; ++i) 
        cin >> arr[i];
    arr.emplace_back(L);
    sort(arr.begin(), arr.end());

    long long max_length = binarySearch();
  
    int index = K, sum = 0, cuts_left = C;
    for (int i = arr.size() - 1; i > 0; --i) 
    {
        if (sum + arr[i] - arr[i - 1] > max_length) 
        {
            sum = arr[i] - arr[i - 1];
            cuts_left--;
            index = i;
        } 
        else
            sum += arr[i] - arr[i - 1];
    }
    if (cuts_left > 0) 
	    index = 1;
    cout << max_length << " " << arr[index] << endl;

    return 0;
}
```

위의 코드는 통나무를 전부 자르는 것이 아닌 자를 수 있는지 여부만 판단하여 통나무의 최대길이와 최대길이를 토재로 처음 자른 부분을 계산하도록 설계되었습니다.


우선 이진 탐색을 통해, 통나무를 반절로 자를 수 있는지 확인합니다. 자를 수 있는지 여부는 possible 함수를 통하여 구하게 되고, 자를 수 있다면, 더 작은 범위도 자를 수 있는지 확인합니다.
(high가 mid이 되면 범위가 줄고, low가 mid가 되면 범위가 늘어난다.)

코드에 대한 설명은 다음과 같습니다.

```cpp
if (arr[i] - arr[i - 1] > mid)
            return false;
```

통나무의 절반이 3이라고 가정할 때, 3만큼으로 자르는 방법은 3으로 자르는 방법도 있지만,
10으로 자른 통나무의 오른쪽 부터 7만큼 자른다면 왼쪽에는 3만큼 남을 것입니다.


```cpp
if (sum + arr[i] - arr[i - 1] > mid) 
        {
            cut++;
            sum = arr[i] - arr[i - 1];
        } 
        else 
            sum += arr[i] - arr[i - 1];
```
조건문의 else 부분은 해당 부분 합을 누적하여 mid를 초과하는지 확인하는 것입니다.
12345로 예시를 들면

2-1 : (1/1) sum=1
3-2+sum(2에서 1로 나눈 것) : (1/1/1)
4-3+sum: (1/1/1) : mid 초과 그래서 한번 자름
5-4+sum: (1) : sum=2

이런 식으로 진행됨

이 과정에서 자른 수가 C번 이하일 수 있는지 확인하여 반환함

```cpp
int index = K, sum = 0, cuts_left = C;
    for (int i = arr.size() - 1; i > 0; --i) 
    {
        if (sum + arr[i] - arr[i - 1] > max_length) 
        {
            sum = arr[i] - arr[i - 1];
            cuts_left--;
            index = i;
        } 
        else
            sum += arr[i] - arr[i - 1];
    }
    if (cuts_left > 0) 
	    index = 1;
```

cuts_left는 총 자를 수 있는 횟수로 자를 때마다 1씩 줄어들어 최대한 자를 수 있는데 까지 자릅니다.
만일 해당 변수가 0보다 크다면 자를 횟수가 여유가 있기에 mid 사이즈로 자를 수 있습니다.

if문은 possible의 if문과 거의 유사합니다.

index는 이진 검색으로 구한 max_length보다 큰 값이라면 자르고 자른 부분을 인덱스로 가집니다.



ex) 만일 13456의 경우는 다음과 같다고 생각하면 됨
((((1/23)4)5)6)
6안에 5를 포함, 해당 5에 4를 포함, 4에 3을 포함, 3에 1을 포함
이 때, 최대 2까지 처리할 수 있을 것임

mid가 3이라면 3을 넘길 때마 잘라주면 됨

